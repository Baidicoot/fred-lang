# a b -> b a
swap: pair uncons

# {a b} -> a b
unpair: uncons swap

# a b -> {b a}
cons: swap pair

# a b c -> b c a
rot3: pair pair reorder unpair uncons
# a b c -> c a b
unrot3: rot3 rot3

# a b c d -> b c d a
rot4: pair pair pair reorder unpair reorder unpair uncons
# a b c d -> d a b c
unrot4: rot4 rot4 rot4

# a b c d e -> b c d e a
rot5: pair pair pair pair reorder unpair reorder unpair reorder unpair uncons
# a b c d e -> e a b c d
unrot5: rot5 rot5 rot5 rot5

# fn1 fn2 b -> if b then fn1() else fn2()
if: call call

# b fn1 fn2 -> if b then fn1() else fn2()
ifr: rot3 if

# fn b -> if b then fn()
branch: 'unit swap if

unit:
(): '()

# a b -> a
true: drop
# a b -> b
false: swap drop

# b -> !b
not: 'false 'true rot3 call

zero: () 'true pair
# x -> (x + 1)
succ: 'false pair
# a -> 0
_constzero: drop zero
# x -> (x - 1)
pred: unpair '_constzero swap 'unit swap if

# 0 -> true
# 1 -> false
iszero: uncons drop

add_internal: swap succ swap pred dup iszero not 'add_internal swap branch
# a b -> (a + b)
add: dup iszero not 'add_internal swap branch drop

# nil list - {() true}
nil: () 'true pair

# xs x -> {{xs x} false}
;: pair 'false pair

# {{xs x} false} -> xs x
un;: unpair drop unpair

# nil -> true
# {{xs x} false} -> false
isnil: unpair swap drop

# {fn1 fn2} {{xs x} false} -> xs x fn1()
case_cons: un; rot3 unpair drop call

# {fn1 fn2} nil -> fn2()
case_nil: drop unpair swap drop call

# rec_list: {{xs x} false} fn1 _ -> xs x fn1()
# rec_list: nil _ fn2 -> fn2()
rec_list: pair swap dup isnil 'case_nil 'case_cons ifr

# bs -> bs
++_rec_nil:

# bs as a -> {(as ++ bs) a}
++_rec_cons: unrot3 ++ swap ;

++: '++_rec_cons '++_rec_nil rec_list